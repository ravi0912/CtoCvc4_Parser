-- Automatically generated by the SPARK High-Level Synthesis System
-- Wed Jun 16 01:40:51 2010, source file : minsort.c

-- 'SPARK' should be defined as the user package
PACKAGE spark_pkg is
  TYPE integer_vector IS ARRAY ( NATURAL RANGE <>) OF integer;
  TYPE boolean_vector IS ARRAY ( NATURAL RANGE <>) OF boolean;
  FUNCTION integer_wired_or ( arr_int : integer_vector ) RETURN integer;
  FUNCTION boolean_wired_or ( arr_bool : boolean_vector ) RETURN boolean;
  SUBTYPE wiredOrInt IS integer_wired_or integer;
  SUBTYPE wiredOrBoolean IS boolean_wired_or boolean;
  TYPE ARRAY_7_0_65535_0 is ARRAY(7 DOWNTO 0) of wiredOrInt range 0 to 65535;
END spark_pkg;


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

PACKAGE BODY spark_pkg IS
  FUNCTION integer_wired_or ( arr_int : integer_vector ) RETURN integer is
    -- pragma resolution_method wired_or
    variable i : integer;
    variable returnVal : std_logic_vector(15 downto 0);
    variable arr_int_std_logic_vec : std_logic_vector(15 downto 0);
  BEGIN
    returnVal := (others => '0');
    for i in arr_int'range loop
      arr_int_std_logic_vec := conv_std_logic_vector(arr_int(i), 16);
      returnVal := returnVal or arr_int_std_logic_vec;
    end loop;
    RETURN conv_integer(returnVal);
  END integer_wired_or;

  FUNCTION boolean_wired_or ( arr_bool : boolean_vector ) RETURN boolean is
    -- pragma resolution_method wired_or
    variable i : integer;
    variable returnVal : boolean;
  BEGIN
    returnVal := FALSE;
    for i in arr_bool'range loop
      returnVal := returnVal or arr_bool(i);
    end loop;
    RETURN returnVal;
  END boolean_wired_or;
end spark_pkg;

library IEEE;
library DWARE,SYNOPSYS;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use SYNOPSYS.attributes.all;


library work;
use work.spark_pkg.all;


ENTITY sort IS 
port(
  n :  IN wiredOrInt range 0 to 65535 ;


-- global variables are 
  a : INOUT ARRAY_7_0_65535_0;
  CLOCK : IN std_logic ;
  RESET : IN std_logic ;
  done : OUT std_logic );
END sort;

ARCHITECTURE rtl OF sort IS

  signal min : wiredOrInt range 0 to 65535 ;
  signal i : wiredOrInt range 0 to 65535 ;
  signal j : wiredOrInt range 0 to 65535 ;
  signal temp : wiredOrInt range 0 to 65535 ;
  signal j_star : wiredOrInt range 0 to 65535 ;
  signal sT0_13 : wiredOrInt range 0 to 65535 ;
  signal sT1_13 : wiredOrBoolean  ;
  signal sT2_15 : wiredOrInt range 0 to 65535 ;
  signal sT3_15 : wiredOrBoolean  ;
  signal sT4_16 : wiredOrInt range 0 to 65535 ;
  signal sT5_16 : wiredOrBoolean  ;
  signal sT6_15 : wiredOrInt range 0 to 65535 ;
  signal sT7_16 : wiredOrInt range 0 to 65535 ;
  signal sT8_16 : wiredOrBoolean  ;
  signal sT9_15 : wiredOrInt range 0 to 65535 ;
  signal sT11_15 : wiredOrInt range 0 to 65535 ;
  signal sT12_15 : wiredOrInt range 0 to 65535 ;
  signal sT13_14 : wiredOrInt range 0 to 65535 ;
  signal sT14_15 : wiredOrInt range 0 to 65535 ;

  -- Statistics collected about this Schedule
  -- Scheduled with the following resources 
  -- 2 ALU, 1 MUL, 2 CMP, 2 SHFT, 2 ARR, 4 LOGIC, 4 GATE, 2 ALLCALLS, 1 a, 
  -- Declarations of the 17 states in routine sort
  subtype StateType is std_logic_vector(16 downto 0);
  CONSTANT S_0 : std_logic_vector(16 downto 0) := "00000000000000001";
  CONSTANT S_1 : std_logic_vector(16 downto 0) := "00000000000000010";
  CONSTANT S_2 : std_logic_vector(16 downto 0) := "00000000000000100";
  CONSTANT S_3 : std_logic_vector(16 downto 0) := "00000000000001000";
  CONSTANT S_4 : std_logic_vector(16 downto 0) := "00000000000010000";
  CONSTANT S_5 : std_logic_vector(16 downto 0) := "00000000000100000";
  CONSTANT S_6 : std_logic_vector(16 downto 0) := "00000000001000000";
  CONSTANT S_7 : std_logic_vector(16 downto 0) := "00000000010000000";
  CONSTANT S_8 : std_logic_vector(16 downto 0) := "00000000100000000";
  CONSTANT S_9 : std_logic_vector(16 downto 0) := "00000001000000000";
  CONSTANT S_10 : std_logic_vector(16 downto 0) := "00000010000000000";
  CONSTANT S_11 : std_logic_vector(16 downto 0) := "00000100000000000";
  CONSTANT S_12 : std_logic_vector(16 downto 0) := "00001000000000000";
  CONSTANT S_13 : std_logic_vector(16 downto 0) := "00010000000000000";
  CONSTANT S_14 : std_logic_vector(16 downto 0) := "00100000000000000";
  CONSTANT S_15 : std_logic_vector(16 downto 0) := "01000000000000000";
  CONSTANT S_16 : std_logic_vector(16 downto 0) := "10000000000000000";
  signal CURRENT_STATE : StateType;
  signal NEXT_STATE : StateType;
  BEGIN
    SYNC: PROCESS
    BEGIN
      wait until CLOCK'event and CLOCK = '1';
      if reset = '1' then
        CURRENT_STATE <= S_0;
        done <= '0';
      else
        CURRENT_STATE <= NEXT_STATE;
        if CURRENT_STATE /= S_0 and NEXT_STATE = S_0 then
          done <= '1';
        end if;
      end if;   -- if reset check
    END PROCESS;   -- SYNC Process

    FSM: PROCESS(CURRENT_STATE, sT8_16, sT3_15, sT1_13)
    BEGIN
      NEXT_STATE <= CURRENT_STATE;
      if CURRENT_STATE(0) = '1' then
        NEXT_STATE <= S_1;
      elsif CURRENT_STATE(1) = '1' then
        NEXT_STATE <= S_2;
      elsif CURRENT_STATE(2) = '1' then
        NEXT_STATE <= S_3;
      elsif CURRENT_STATE(3) = '1' then
        NEXT_STATE <= S_4;
      elsif CURRENT_STATE(4) = '1' then
        NEXT_STATE <= S_5;
      elsif CURRENT_STATE(5) = '1' then
        NEXT_STATE <= S_6;
      elsif CURRENT_STATE(6) = '1' then
        NEXT_STATE <= S_7;
      elsif CURRENT_STATE(7) = '1' then
        NEXT_STATE <= S_8;
      elsif CURRENT_STATE(8) = '1' then
        NEXT_STATE <= S_9;
      elsif CURRENT_STATE(9) = '1' then
        NEXT_STATE <= S_10;
      elsif CURRENT_STATE(10) = '1' then
        NEXT_STATE <= S_11;
      elsif CURRENT_STATE(11) = '1' then
        if sT1_13 then
          NEXT_STATE <= S_12;
        else  -- sT1_13        
          NEXT_STATE <= S_0;
        end if; -- conditions
      elsif CURRENT_STATE(12) = '1' then
        NEXT_STATE <= S_13;
      elsif CURRENT_STATE(13) = '1' then
        NEXT_STATE <= S_14;
      elsif CURRENT_STATE(14) = '1' then
        if sT1_13 then
          if sT3_15 then
            if sT8_16 then
              NEXT_STATE <= S_12;
            else  -- sT8_16            
              NEXT_STATE <= S_12;
            end if;  -- NOT(sT8_16)            
          else  -- sT3_15          
            NEXT_STATE <= S_15;
          end if; -- conditions
        end if; -- conditions
      elsif CURRENT_STATE(15) = '1' then
        NEXT_STATE <= S_16;
      elsif CURRENT_STATE(16) = '1' then
        NEXT_STATE <= S_9;
      END if;  -- if (CURRENT_STATE)
    END PROCESS;   -- FSM Process

    DP: PROCESS
    variable sT10_15 : wiredOrInt range 0 to 65535 ;

    BEGIN
      wait until CLOCK'event and CLOCK = '1';
      if reset = '1' then
        sT1_13 <= FALSE;
        sT3_15 <= FALSE;
        sT8_16 <= FALSE;
      else   -- else of   if reset
        if CURRENT_STATE(0) = '1' then
          a(0) <= 23;
          i  <=  0;
        elsif CURRENT_STATE(1) = '1' then
          a(1) <= 11;
        elsif CURRENT_STATE(2) = '1' then
          a(2) <= 27;
        elsif CURRENT_STATE(3) = '1' then
          a(3) <= 19;
        elsif CURRENT_STATE(4) = '1' then
          a(4) <= 12;
        elsif CURRENT_STATE(5) = '1' then
          a(5) <= 10;
        elsif CURRENT_STATE(6) = '1' then
          a(6) <= 31;
        elsif CURRENT_STATE(7) = '1' then
          a(7) <= 7;
        elsif CURRENT_STATE(8) = '1' then
          min  <=  a(0);
        elsif CURRENT_STATE(9) = '1' then
          sT0_13  <=  (n - 2);
          sT12_15  <=  (i + 1);
          sT13_14  <=  a(i);
        elsif CURRENT_STATE(10) = '1' then
          sT14_15  <=  (n - 1);
          sT1_13  <=  (i <= sT0_13);
        elsif CURRENT_STATE(11) = '1' then
          if sT1_13 then
            min  <=  sT13_14;
            j_star  <=  i;
            j  <=  sT12_15;
            sT10_15  :=  sT14_15;
            sT2_15  <=  sT14_15;
            sT9_15  <=  sT14_15;
            temp  <=  sT13_14;
          end if; -- conditions
        elsif CURRENT_STATE(12) = '1' then
          if sT1_13 then
            sT11_15  <=  (n - 1);
            sT6_15  <=  (j + 1);
            sT3_15  <=  (j <= sT2_15);
            sT7_16  <=  a(j);
          end if; -- conditions
        elsif CURRENT_STATE(13) = '1' then
          if sT1_13 then
            sT8_16  <=  (sT7_16 < min);
          end if; -- conditions
        elsif CURRENT_STATE(14) = '1' then
          if sT1_13 then
            if sT3_15 then
              if sT8_16 then
                sT4_16  <=  sT7_16;
                sT5_16  <=  sT8_16;
                min  <=  sT7_16;
                j_star  <=  j;
                j  <=  sT6_15;
                sT2_15  <=  sT9_15;
                sT9_15  <=  sT11_15;
              else  -- sT8_16              
                sT4_16  <=  sT7_16;
                sT5_16  <=  sT8_16;
                j  <=  sT6_15;
                sT2_15  <=  sT9_15;
                sT9_15  <=  sT11_15;
              end if; -- conditions
            end if; -- conditions
          end if; -- conditions
        elsif CURRENT_STATE(15) = '1' then
          if sT1_13 then
            a(i) <= sT13_14;
            i  <=  sT12_15;
          end if; -- conditions
        elsif CURRENT_STATE(16) = '1' then
          if sT1_13 then
            a(j_star) <= sT13_14;
          end if; -- conditions
        END if;  -- if (CURRENT_STATE)
      end if;   -- end of   if reset
    END PROCESS;   -- DP Process

END rtl;
