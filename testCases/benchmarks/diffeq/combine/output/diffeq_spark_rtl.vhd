-- Automatically generated by the SPARK High-Level Synthesis System
-- Wed May  4 13:58:21 2011, source file : diffeq.c

-- 'SPARK' should be defined as the user package
PACKAGE spark_pkg is
  TYPE integer_vector IS ARRAY ( NATURAL RANGE <>) OF integer;
  TYPE boolean_vector IS ARRAY ( NATURAL RANGE <>) OF boolean;
  FUNCTION integer_wired_or ( arr_int : integer_vector ) RETURN integer;
  FUNCTION boolean_wired_or ( arr_bool : boolean_vector ) RETURN boolean;
  SUBTYPE wiredOrInt IS integer_wired_or integer;
  SUBTYPE wiredOrBoolean IS boolean_wired_or boolean;
END spark_pkg;


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

PACKAGE BODY spark_pkg IS
  FUNCTION integer_wired_or ( arr_int : integer_vector ) RETURN integer is
    -- pragma resolution_method wired_or
    variable i : integer;
    variable returnVal : std_logic_vector(15 downto 0);
    variable arr_int_std_logic_vec : std_logic_vector(15 downto 0);
  BEGIN
    returnVal := (others => '0');
    for i in arr_int'range loop
      arr_int_std_logic_vec := conv_std_logic_vector(arr_int(i), 16);
      returnVal := returnVal or arr_int_std_logic_vec;
    end loop;
    RETURN conv_integer(returnVal);
  END integer_wired_or;

  FUNCTION boolean_wired_or ( arr_bool : boolean_vector ) RETURN boolean is
    -- pragma resolution_method wired_or
    variable i : integer;
    variable returnVal : boolean;
  BEGIN
    returnVal := FALSE;
    for i in arr_bool'range loop
      returnVal := returnVal or arr_bool(i);
    end loop;
    RETURN returnVal;
  END boolean_wired_or;
end spark_pkg;

library IEEE;

library DWARE,SYNOPSYS;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use SYNOPSYS.attributes.all;


ENTITY res_ALU IS
port(
  res_ALU_in0 : IN integer range -32767 to 32768;
  res_ALU_in1 : IN integer range -32767 to 32768;
  res_ALU_execOp : IN integer range 0 to 1;
  res_ALU_out : OUT integer range -32767 to 32768
);
END res_ALU;

ARCHITECTURE rtl of res_ALU IS
BEGIN
  res_ALU_out <= res_ALU_in0 +  res_ALU_in1   when (res_ALU_execOp = 0)
       else res_ALU_in0 -  res_ALU_in1;
END rtl;  -- architecture of res_ALU

library IEEE;

library DW02,DWARE,SYNOPSYS;
use DW02.DW02_components.all;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use SYNOPSYS.attributes.all;


ENTITY res_MUL IS
port(
  res_MUL_in0 : IN integer range -32767 to 32768;
  res_MUL_in1 : IN integer range -32767 to 32768;
  res_MUL_out : OUT integer range -32767 to 32768;
  CLOCK : IN std_logic
);
END res_MUL;

ARCHITECTURE rtl of res_MUL IS
  signal in1_vec : std_logic_vector(15 downto 0);
  signal in2_vec : std_logic_vector(15 downto 0);
  signal out_vec : std_logic_vector(31 downto 0);
  signal TC_inst : std_logic;
BEGIN
  in1_vec <= conv_std_logic_vector(res_MUL_in0, 16);
  in2_vec <= conv_std_logic_vector(res_MUL_in1, 16);
  TC_inst <= '1';
  U1 : DW02_mult_2_stage
      generic map ( A_width => 16,
                    B_width => 16 )
      port map ( A => in1_vec, B => in2_vec, TC => TC_inst,
                 CLK => CLOCK, PRODUCT => out_vec );
  res_MUL_out <= conv_integer(out_vec);
END rtl;  -- architecture of res_MUL

library IEEE;

library DWARE,SYNOPSYS;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use SYNOPSYS.attributes.all;


ENTITY res_CMP IS
port(
  res_CMP_in0 : IN integer range -32767 to 32768;
  res_CMP_in1 : IN integer range -32767 to 32768;
  res_CMP_execOp : IN integer range 0 to 5;
  res_CMP_out : OUT boolean
);
END res_CMP;

ARCHITECTURE rtl of res_CMP IS
BEGIN
  res_CMP_out <= res_CMP_in0 /=  res_CMP_in1   when (res_CMP_execOp = 0)
       else res_CMP_in0 =  res_CMP_in1        when (res_CMP_execOp = 1)
       else res_CMP_in0 <  res_CMP_in1        when (res_CMP_execOp = 2)
       else res_CMP_in0 >  res_CMP_in1        when (res_CMP_execOp = 3)
       else res_CMP_in0 >=  res_CMP_in1        when (res_CMP_execOp = 4)
       else res_CMP_in0 <=  res_CMP_in1;
END rtl;  -- architecture of res_CMP

library IEEE;

library DWARE,SYNOPSYS;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use SYNOPSYS.attributes.all;


ENTITY res_SHFT IS
port(
  res_SHFT_in0 : IN integer range -32767 to 32768;
  res_SHFT_in1 : IN integer range -32767 to 32768;
  res_SHFT_execOp : IN integer range 0 to 1;
  res_SHFT_out : OUT integer range -32767 to 32768
);
END res_SHFT;

ARCHITECTURE rtl of res_SHFT IS
BEGIN
  res_SHFT_out <= conv_integer(
            shl(conv_std_logic_vector(res_SHFT_in0, 16),
                conv_std_logic_vector(res_SHFT_in1, 16) ))
               when (res_SHFT_execOp = 0)
       else conv_integer(
                 shr(conv_std_logic_vector(res_SHFT_in0, 16),
                     conv_std_logic_vector(res_SHFT_in1, 16) ))
                 ;
END rtl;  -- architecture of res_SHFT

library IEEE;

library DWARE,SYNOPSYS;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use SYNOPSYS.attributes.all;


ENTITY res_ARR IS
port(
  res_ARR_in0 : IN integer range -32767 to 32768;
  res_ARR_out : OUT integer range -32767 to 32768
);
END res_ARR;

ARCHITECTURE rtl of res_ARR IS
BEGIN
  res_ARR_out <= res_ARR_in0;
END rtl;  -- architecture of res_ARR

library IEEE;

library DWARE,SYNOPSYS;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use SYNOPSYS.attributes.all;


ENTITY res_LOGIC IS
port(
  res_LOGIC_in0 : IN boolean;
  res_LOGIC_in1 : IN boolean;
  res_LOGIC_execOp : IN integer range 0 to 1;
  res_LOGIC_out : OUT boolean
);
END res_LOGIC;

ARCHITECTURE rtl of res_LOGIC IS
BEGIN
  res_LOGIC_out <= res_LOGIC_in0 and  res_LOGIC_in1   when (res_LOGIC_execOp = 0)
       else res_LOGIC_in0 or  res_LOGIC_in1;
END rtl;  -- architecture of res_LOGIC

library IEEE;

library DWARE,SYNOPSYS;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use SYNOPSYS.attributes.all;


ENTITY res_GATE IS
port(
  res_GATE_in0 : IN integer range -32767 to 32768;
  res_GATE_in1 : IN integer range -32767 to 32768;
  res_GATE_execOp : IN integer range 0 to 1;
  res_GATE_out : OUT integer range -32767 to 32768
);
END res_GATE;

ARCHITECTURE rtl of res_GATE IS
BEGIN
  res_GATE_out <= conv_integer(
            conv_std_logic_vector(res_GATE_in0, 16) and 
            conv_std_logic_vector(res_GATE_in1, 16) )
               when (res_GATE_execOp = 0)
       else conv_integer(
                 conv_std_logic_vector(res_GATE_in0, 16) or 
                 conv_std_logic_vector(res_GATE_in1, 16) )
                 ;
END rtl;  -- architecture of res_GATE

library IEEE;
library DWARE,SYNOPSYS;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;
use SYNOPSYS.attributes.all;


library work;
use work.spark_pkg.all;


ENTITY main IS 
port(
  returnVar_main :  OUT wiredOrInt range -32767 to 32768 ;
  CLOCK : IN std_logic ;
  RESET : IN std_logic ;
  done : OUT std_logic );
END main;

ARCHITECTURE rtl OF main IS

  COMPONENT res_ALU
  port(
    res_ALU_in0 : IN integer range -32767 to 32768;
    res_ALU_in1 : IN integer range -32767 to 32768;
    res_ALU_execOp : IN integer range 0 to 1;
    res_ALU_out : OUT integer range -32767 to 32768
  );
  END COMPONENT;  -- end of component res_ALU

  COMPONENT res_MUL
  port(
    res_MUL_in0 : IN integer range -32767 to 32768;
    res_MUL_in1 : IN integer range -32767 to 32768;
    res_MUL_out : OUT integer range -32767 to 32768;
    CLOCK : IN std_logic
  );
  END COMPONENT;  -- end of component res_MUL

  COMPONENT res_CMP
  port(
    res_CMP_in0 : IN integer range -32767 to 32768;
    res_CMP_in1 : IN integer range -32767 to 32768;
    res_CMP_execOp : IN integer range 0 to 5;
    res_CMP_out : OUT boolean
  );
  END COMPONENT;  -- end of component res_CMP

  COMPONENT res_SHFT
  port(
    res_SHFT_in0 : IN integer range -32767 to 32768;
    res_SHFT_in1 : IN integer range -32767 to 32768;
    res_SHFT_execOp : IN integer range 0 to 1;
    res_SHFT_out : OUT integer range -32767 to 32768
  );
  END COMPONENT;  -- end of component res_SHFT

  signal sT0_7 : wiredOrBoolean  ;

  signal res_ALU_0_in0 : integer range -32767 to 32768 := 0;
  signal res_ALU_0_in1 : integer range -32767 to 32768 := 0;
  signal res_ALU_0_execOp : integer range 0 to 1 := 0;
  signal res_ALU_0_out : integer range -32767 to 32768 := 0;
  signal res_ALU_1_in0 : integer range -32767 to 32768 := 0;
  signal res_ALU_1_in1 : integer range -32767 to 32768 := 0;
  signal res_ALU_1_execOp : integer range 0 to 1 := 0;
  signal res_ALU_1_out : integer range -32767 to 32768 := 0;
  signal res_MUL_2_in0 : integer range -32767 to 32768 := 0;
  signal res_MUL_2_in1 : integer range -32767 to 32768 := 0;
  signal res_MUL_2_out : integer range -32767 to 32768 := 0;
  signal res_CMP_3_in0 : integer range -32767 to 32768 := 0;
  signal res_CMP_3_in1 : integer range -32767 to 32768 := 0;
  signal res_CMP_3_execOp : integer range 0 to 5 := 0;
  signal res_CMP_3_out : boolean;
  signal res_SHFT_5_in0 : integer range -32767 to 32768 := 0;
  signal res_SHFT_5_in1 : integer range -32767 to 32768 := 0;
  signal res_SHFT_5_execOp : integer range 0 to 1 := 0;
  signal res_SHFT_5_out : integer range -32767 to 32768 := 0;
  -- Statistics collected about this Schedule
  -- Scheduled with the following resources 
  -- 2 ALU, 1 MUL, 2 CMP, 2 SHFT, 2 ARR, 5 LOGIC, 5 GATE, 2 ALLCALLS, 
  -- Declarations of the 12 states in routine main
  subtype StateType is std_logic_vector(11 downto 0);
  CONSTANT S_0 : std_logic_vector(11 downto 0) := "000000000001";
  CONSTANT S_1 : std_logic_vector(11 downto 0) := "000000000010";
  CONSTANT S_2 : std_logic_vector(11 downto 0) := "000000000100";
  CONSTANT S_3 : std_logic_vector(11 downto 0) := "000000001000";
  CONSTANT S_4 : std_logic_vector(11 downto 0) := "000000010000";
  CONSTANT S_5 : std_logic_vector(11 downto 0) := "000000100000";
  CONSTANT S_6 : std_logic_vector(11 downto 0) := "000001000000";
  CONSTANT S_7 : std_logic_vector(11 downto 0) := "000010000000";
  CONSTANT S_8 : std_logic_vector(11 downto 0) := "000100000000";
  CONSTANT S_9 : std_logic_vector(11 downto 0) := "001000000000";
  CONSTANT S_10 : std_logic_vector(11 downto 0) := "010000000000";
  CONSTANT S_11 : std_logic_vector(11 downto 0) := "100000000000";
  signal CURRENT_STATE : StateType;
  signal NEXT_STATE : StateType;
  -- Declarations of the 19 registers in main
  signal regNum0 : integer range -32767 to 32768 := 0;
  signal regNum1 : integer range -32767 to 32768 := 0;
  signal regNum2 : integer range -32767 to 32768 := 0;
  signal regNum3 : integer range -32767 to 32768 := 0;
  signal regNum4 : integer range -32767 to 32768 := 0;
  signal regNum5 : integer range -32767 to 32768 := 0;
  signal regNum6 : integer range -32767 to 32768 := 0;
  signal regNum7 : integer range -32767 to 32768 := 0;
  signal regNum8 : integer range -32767 to 32768 := 0;
  signal regNum9 : integer range -32767 to 32768 := 0;
  signal regNum10 : integer range -32767 to 32768 := 0;
  signal regNum11 : integer range -32767 to 32768 := 0;
  signal regNum12 : integer range -32767 to 32768 := 0;
  signal regNum13 : integer range -32767 to 32768 := 0;
  signal regNum14 : integer range -32767 to 32768 := 0;
  signal regNum15 : integer range -32767 to 32768 := 0;
  signal regNum16 : integer range -32767 to 32768 := 0;
  signal regNum17 : integer range -32767 to 32768 := 0;
  signal regNum18 : integer range -32767 to 32768 := 0;
  BEGIN
    res_ALU_instance_0 : res_ALU
    port map (
      res_ALU_in0 => res_ALU_0_in0,
      res_ALU_in1 => res_ALU_0_in1,
      res_ALU_execOp => res_ALU_0_execOp,
      res_ALU_out => res_ALU_0_out
    );
    -- end of port map of component res_ALU_instance_0

    res_ALU_instance_1 : res_ALU
    port map (
      res_ALU_in0 => res_ALU_1_in0,
      res_ALU_in1 => res_ALU_1_in1,
      res_ALU_execOp => res_ALU_1_execOp,
      res_ALU_out => res_ALU_1_out
    );
    -- end of port map of component res_ALU_instance_1

    res_MUL_instance_2 : res_MUL
    port map (
      res_MUL_in0 => res_MUL_2_in0,
      res_MUL_in1 => res_MUL_2_in1,
      res_MUL_out => res_MUL_2_out,
      CLOCK => CLOCK
    );
    -- end of port map of component res_MUL_instance_2

    res_CMP_instance_3 : res_CMP
    port map (
      res_CMP_in0 => res_CMP_3_in0,
      res_CMP_in1 => res_CMP_3_in1,
      res_CMP_execOp => res_CMP_3_execOp,
      res_CMP_out => res_CMP_3_out
    );
    -- end of port map of component res_CMP_instance_3

    res_SHFT_instance_5 : res_SHFT
    port map (
      res_SHFT_in0 => res_SHFT_5_in0,
      res_SHFT_in1 => res_SHFT_5_in1,
      res_SHFT_execOp => res_SHFT_5_execOp,
      res_SHFT_out => res_SHFT_5_out
    );
    -- end of port map of component res_SHFT_instance_5

    SYNC: PROCESS
    BEGIN
      wait until CLOCK'event and CLOCK = '1';
      if reset = '1' then
        CURRENT_STATE <= S_0;
        done <= '0';
      else
        CURRENT_STATE <= NEXT_STATE;
        if CURRENT_STATE /= S_0 and NEXT_STATE = S_0 then
          done <= '1';
        end if;
      end if;   -- if reset check
    END PROCESS;   -- SYNC Process

    FSM: PROCESS(CURRENT_STATE, sT0_7)
    BEGIN
      NEXT_STATE <= CURRENT_STATE;
      if CURRENT_STATE(0) = '1' then
        NEXT_STATE <= S_1;
      elsif CURRENT_STATE(1) = '1' then
        NEXT_STATE <= S_2;  -- multicycle op
      elsif CURRENT_STATE(2) = '1' then
        NEXT_STATE <= S_3;
      elsif CURRENT_STATE(3) = '1' then
        if sT0_7 then
          NEXT_STATE <= S_4;  -- multicycle op
        else  -- sT0_7        
          NEXT_STATE <= S_11;
        end if; -- conditions
      elsif CURRENT_STATE(4) = '1' then
        NEXT_STATE <= S_5;
      elsif CURRENT_STATE(5) = '1' then
        NEXT_STATE <= S_6;  -- multicycle op
      elsif CURRENT_STATE(6) = '1' then
        NEXT_STATE <= S_7;
      elsif CURRENT_STATE(7) = '1' then
        NEXT_STATE <= S_8;
      elsif CURRENT_STATE(8) = '1' then
        NEXT_STATE <= S_9;  -- multicycle op
      elsif CURRENT_STATE(9) = '1' then
        NEXT_STATE <= S_10;
      elsif CURRENT_STATE(10) = '1' then
        NEXT_STATE <= S_1;
      elsif CURRENT_STATE(11) = '1' then
        NEXT_STATE <= S_0;
      END if;  -- if (CURRENT_STATE)
    END PROCESS;   -- FSM Process

    DP: PROCESS

    BEGIN
      wait until CLOCK'event and CLOCK = '1';
      if reset = '1' then
        sT0_7 <= FALSE;
      else   -- else of   if reset
        if CURRENT_STATE(0) = '1' then
          regNum0 <= 0;
        elsif CURRENT_STATE(1) = '1' then
          regNum1 <= res_ALU_0_out;
          regNum2 <= res_ALU_1_out;
          regNum4 <= res_SHFT_5_out;
        elsif CURRENT_STATE(2) = '1' then
          regNum3 <= res_MUL_2_out;
          sT0_7 <= res_CMP_3_out;
          regNum5 <= res_SHFT_5_out;
        elsif CURRENT_STATE(3) = '1' then
          if sT0_7 then
            regNum7 <= regNum3;
            regNum8 <= regNum5;
            regNum9 <= regNum4;
            regNum10 <= regNum1;
            regNum0 <= regNum2;
          end if; -- conditions
        elsif CURRENT_STATE(4) = '1' then
          if sT0_7 then
            regNum6 <= res_MUL_2_out;
          end if; -- conditions
        elsif CURRENT_STATE(5) = '1' then
          if sT0_7 then
            regNum11 <= res_ALU_0_out;
          end if; -- conditions
        elsif CURRENT_STATE(6) = '1' then
          if sT0_7 then
            regNum12 <= res_MUL_2_out;
          end if; -- conditions
        elsif CURRENT_STATE(7) = '1' then
          if sT0_7 then
            regNum13 <= res_ALU_0_out;
          end if; -- conditions
        elsif CURRENT_STATE(8) = '1' then
        elsif CURRENT_STATE(9) = '1' then
          if sT0_7 then
            regNum14 <= res_MUL_2_out;
          end if; -- conditions
        elsif CURRENT_STATE(10) = '1' then
          if sT0_7 then
            regNum15 <= res_ALU_0_out;
          end if; -- conditions
        elsif CURRENT_STATE(11) = '1' then
          regNum16 <= regNum10;
          regNum17 <= regNum15;
          regNum18 <= regNum13;
          returnVar_main <= 0;
        END if;  -- if (CURRENT_STATE)
      end if;   -- end of   if reset
    END PROCESS;   -- DP Process

    res_ALU_0_in0_MUXES: PROCESS(CURRENT_STATE
        , regNum1, sT0_7, regNum13, sT0_7, regNum11, sT0_7, regNum15)
      variable mux_select : std_logic_vector(4 downto 0);
    BEGIN
      mux_select := "00000";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "00001";
      end if;
      if (CURRENT_STATE(5) = '1' and sT0_7) then
        mux_select := "00010";
      end if;
      if (CURRENT_STATE(7) = '1' and sT0_7) then
        mux_select := "00100";
      end if;
      if (CURRENT_STATE(10) = '1' and sT0_7) then
        mux_select := "01000";
      end if;
      case mux_select is
        when "00001" => 
          res_ALU_0_in0 <= regNum1;
        when "00010" => 
          res_ALU_0_in0 <= regNum13;
        when "00100" => 
          res_ALU_0_in0 <= regNum11;
        when "01000" => 
          res_ALU_0_in0 <= regNum15;
        when others => 
          res_ALU_0_in0 <= 0;
      END CASE;
    END PROCESS;	 -- res_ALU_0_in0_MUXES END PROCESS;

    res_ALU_0_in1_MUXES: PROCESS(CURRENT_STATE
        , dx, sT0_7, regNum6, sT0_7, regNum12, sT0_7, regNum14)
      variable mux_select : std_logic_vector(4 downto 0);
    BEGIN
      mux_select := "00000";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "00001";
      end if;
      if (CURRENT_STATE(5) = '1' and sT0_7) then
        mux_select := "00010";
      end if;
      if (CURRENT_STATE(7) = '1' and sT0_7) then
        mux_select := "00100";
      end if;
      if (CURRENT_STATE(10) = '1' and sT0_7) then
        mux_select := "01000";
      end if;
      case mux_select is
        when "00001" => 
          res_ALU_0_in1 <= dx;
        when "00010" => 
          res_ALU_0_in1 <= regNum6;
        when "00100" => 
          res_ALU_0_in1 <= regNum12;
        when "01000" => 
          res_ALU_0_in1 <= regNum14;
        when others => 
          res_ALU_0_in1 <= 0;
      END CASE;
    END PROCESS;	 -- res_ALU_0_in1_MUXES END PROCESS;

    res_ALU_0_execOpMUXES: PROCESS(CURRENT_STATE 
        , sT0_7, sT0_7, sT0_7)
      variable mux_select : std_logic_vector(4 downto 0);
    BEGIN
      mux_select := "00000";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "00001";
      end if;
      if (CURRENT_STATE(5) = '1' and sT0_7) then
        mux_select := "00010";
      end if;
      if (CURRENT_STATE(7) = '1' and sT0_7) then
        mux_select := "00100";
      end if;
      if (CURRENT_STATE(10) = '1' and sT0_7) then
        mux_select := "01000";
      end if;
      case mux_select is
        when "00001" => 
          res_ALU_0_execOp <= 0 ;
        when "00010" => 
          res_ALU_0_execOp <= 1 ;
        when "00100" => 
          res_ALU_0_execOp <= 1 ;
        when "01000" => 
          res_ALU_0_execOp <= 0 ;
        when others => 
          res_ALU_0_execOp <= 0;
      END CASE;
    END PROCESS;	 -- res_ALU_0_execOp_MUXES END PROCESS;

    res_ALU_1_in0_MUXES: PROCESS(CURRENT_STATE
        , regNum0)
      variable mux_select : std_logic_vector(4 downto 0);
    BEGIN
      mux_select := "00000";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "00001";
      end if;
      case mux_select is
        when "00001" => 
          res_ALU_1_in0 <= regNum0;
        when others => 
          res_ALU_1_in0 <= 0;
      END CASE;
    END PROCESS;	 -- res_ALU_1_in0_MUXES END PROCESS;

    res_ALU_1_in1_MUXES: PROCESS(CURRENT_STATE
        )
      variable mux_select : std_logic_vector(4 downto 0);
    BEGIN
      mux_select := "00000";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "00001";
      end if;
      case mux_select is
        when "00001" => 
          res_ALU_1_in1 <= 1;
        when others => 
          res_ALU_1_in1 <= 0;
      END CASE;
    END PROCESS;	 -- res_ALU_1_in1_MUXES END PROCESS;

    res_ALU_1_execOpMUXES: PROCESS(CURRENT_STATE 
        )
      variable mux_select : std_logic_vector(4 downto 0);
    BEGIN
      mux_select := "00000";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "00001";
      end if;
      case mux_select is
        when "00001" => 
          res_ALU_1_execOp <= 0 ;
        when others => 
          res_ALU_1_execOp <= 0;
      END CASE;
    END PROCESS;	 -- res_ALU_1_execOp_MUXES END PROCESS;

    res_MUL_2_in0_MUXES: PROCESS(CURRENT_STATE
        , regNum13, sT0_7, regNum3, sT0_7, dx, sT0_7, regNum13)
      variable mux_select : std_logic_vector(3 downto 0);
    BEGIN
      mux_select := "0000";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "0001";
      end if;
      if (CURRENT_STATE(3) = '1' and sT0_7) then
        mux_select := "0010";
      end if;
      if (CURRENT_STATE(5) = '1' and sT0_7) then
        mux_select := "0100";
      end if;
      if (CURRENT_STATE(8) = '1' and sT0_7) then
        mux_select := "1000";
      end if;
      case mux_select is
        when "0001" => 
          res_MUL_2_in0 <= regNum13;
        when "0010" => 
          res_MUL_2_in0 <= regNum3;
        when "0100" => 
          res_MUL_2_in0 <= dx;
        when "1000" => 
          res_MUL_2_in0 <= regNum13;
        when others => 
          res_MUL_2_in0 <= 0;
      END CASE;
    END PROCESS;	 -- res_MUL_2_in0_MUXES END PROCESS;

    res_MUL_2_in1_MUXES: PROCESS(CURRENT_STATE
        , dx, sT0_7, regNum5, sT0_7, regNum4, sT0_7, dx)
      variable mux_select : std_logic_vector(3 downto 0);
    BEGIN
      mux_select := "0000";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "0001";
      end if;
      if (CURRENT_STATE(3) = '1' and sT0_7) then
        mux_select := "0010";
      end if;
      if (CURRENT_STATE(5) = '1' and sT0_7) then
        mux_select := "0100";
      end if;
      if (CURRENT_STATE(8) = '1' and sT0_7) then
        mux_select := "1000";
      end if;
      case mux_select is
        when "0001" => 
          res_MUL_2_in1 <= dx;
        when "0010" => 
          res_MUL_2_in1 <= regNum5;
        when "0100" => 
          res_MUL_2_in1 <= regNum4;
        when "1000" => 
          res_MUL_2_in1 <= dx;
        when others => 
          res_MUL_2_in1 <= 0;
      END CASE;
    END PROCESS;	 -- res_MUL_2_in1_MUXES END PROCESS;

    res_SHFT_5_in0_MUXES: PROCESS(CURRENT_STATE
        , regNum15, regNum1)
      variable mux_select : std_logic_vector(1 downto 0);
    BEGIN
      mux_select := "00";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "01";
      end if;
      if (CURRENT_STATE(2) = '1') then
        mux_select := "10";
      end if;
      case mux_select is
        when "01" => 
          res_SHFT_5_in0 <= regNum15;
        when "10" => 
          res_SHFT_5_in0 <= regNum1;
        when others => 
          res_SHFT_5_in0 <= 0;
      END CASE;
    END PROCESS;	 -- res_SHFT_5_in0_MUXES END PROCESS;

    res_SHFT_5_in1_MUXES: PROCESS(CURRENT_STATE
        )
      variable mux_select : std_logic_vector(1 downto 0);
    BEGIN
      mux_select := "00";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "01";
      end if;
      if (CURRENT_STATE(2) = '1') then
        mux_select := "10";
      end if;
      case mux_select is
        when "01" => 
          res_SHFT_5_in1 <= 1 ;
        when "10" => 
          res_SHFT_5_in1 <= 1 ;
        when others => 
          res_SHFT_5_in1 <= 0;
      END CASE;
    END PROCESS;	 -- res_SHFT_5_in1_MUXES END PROCESS;

    res_SHFT_5_execOpMUXES: PROCESS(CURRENT_STATE 
        )
      variable mux_select : std_logic_vector(1 downto 0);
    BEGIN
      mux_select := "00";
      if (CURRENT_STATE(1) = '1') then
        mux_select := "01";
      end if;
      if (CURRENT_STATE(2) = '1') then
        mux_select := "10";
      end if;
      case mux_select is
        when "01" => 
          res_SHFT_5_execOp <= 0 ;
        when "10" => 
          res_SHFT_5_execOp <= 0 ;
        when others => 
          res_SHFT_5_execOp <= 0;
      END CASE;
    END PROCESS;	 -- res_SHFT_5_execOp_MUXES END PROCESS;

    res_CMP_3_in0_MUXES: PROCESS(CURRENT_STATE
        , regNum1)
      variable mux_select : std_logic_vector(0 downto 0);
    BEGIN
      mux_select := "0";
      if (CURRENT_STATE(2) = '1') then
        mux_select := "1";
      end if;
      case mux_select is
        when "1" => 
          res_CMP_3_in0 <= regNum1;
        when others => 
          res_CMP_3_in0 <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_3_in0_MUXES END PROCESS;

    res_CMP_3_in1_MUXES: PROCESS(CURRENT_STATE
        , a)
      variable mux_select : std_logic_vector(0 downto 0);
    BEGIN
      mux_select := "0";
      if (CURRENT_STATE(2) = '1') then
        mux_select := "1";
      end if;
      case mux_select is
        when "1" => 
          res_CMP_3_in1 <= a;
        when others => 
          res_CMP_3_in1 <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_3_in1_MUXES END PROCESS;

    res_CMP_3_execOpMUXES: PROCESS(CURRENT_STATE 
        )
      variable mux_select : std_logic_vector(0 downto 0);
    BEGIN
      mux_select := "0";
      if (CURRENT_STATE(2) = '1') then
        mux_select := "1";
      end if;
      case mux_select is
        when "1" => 
          res_CMP_3_execOp <= 2 ;
        when others => 
          res_CMP_3_execOp <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_3_execOp_MUXES END PROCESS;

END rtl;
