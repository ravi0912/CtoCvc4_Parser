-- Automatically generated by the SPARK High-Level Synthesis System
-- Wed Jun 16 01:55:04 2010, source file : findmin8.c

-- 'SPARK' should be defined as the user package
PACKAGE spark_pkg is
  TYPE integer_vector IS ARRAY ( NATURAL RANGE <>) OF integer;
  TYPE boolean_vector IS ARRAY ( NATURAL RANGE <>) OF boolean;
  FUNCTION integer_wired_or ( arr_int : integer_vector ) RETURN integer;
  FUNCTION boolean_wired_or ( arr_bool : boolean_vector ) RETURN boolean;
  SUBTYPE wiredOrInt IS integer_wired_or integer;
  SUBTYPE wiredOrBoolean IS boolean_wired_or boolean;
END spark_pkg;


library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

PACKAGE BODY spark_pkg IS
  FUNCTION integer_wired_or ( arr_int : integer_vector ) RETURN integer is
    -- pragma resolution_method wired_or
    variable i : integer;
    variable returnVal : std_logic_vector(31 downto 0);
    variable arr_int_std_logic_vec : std_logic_vector(31 downto 0);
  BEGIN
    returnVal := (others => '0');
    for i in arr_int'range loop
      arr_int_std_logic_vec := conv_std_logic_vector(arr_int(i), 32);
      returnVal := returnVal or arr_int_std_logic_vec;
    end loop;
    RETURN conv_integer(returnVal);
  END integer_wired_or;

  FUNCTION boolean_wired_or ( arr_bool : boolean_vector ) RETURN boolean is
    -- pragma resolution_method wired_or
    variable i : integer;
    variable returnVal : boolean;
  BEGIN
    returnVal := FALSE;
    for i in arr_bool'range loop
      returnVal := returnVal or arr_bool(i);
    end loop;
    RETURN returnVal;
  END boolean_wired_or;
end spark_pkg;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

ENTITY res_ALU IS
port(
  res_ALU_in0 : IN integer range -2147483648 to 2147483647;
  res_ALU_in1 : IN integer range -2147483648 to 2147483647;
  res_ALU_execOp : IN integer range 0 to 1;
  res_ALU_out : OUT integer range -2147483648 to 2147483647
);
END res_ALU;

ARCHITECTURE rtl of res_ALU IS
BEGIN
  res_ALU_out <= res_ALU_in0 +  res_ALU_in1   when (res_ALU_execOp = 0)
       else res_ALU_in0 -  res_ALU_in1;
END rtl;  -- architecture of res_ALU

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

ENTITY res_MUL IS
port(
  res_MUL_in0 : IN integer range -2147483648 to 2147483647;
  res_MUL_in1 : IN integer range -2147483648 to 2147483647;
  res_MUL_out : OUT integer range -2147483648 to 2147483647;
  CLOCK : IN std_logic
);
END res_MUL;

ARCHITECTURE rtl of res_MUL IS
BEGIN
  res_MUL_out <= res_MUL_in0 *  res_MUL_in1;
END rtl;  -- architecture of res_MUL

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

ENTITY res_CMP IS
port(
  res_CMP_in0 : IN integer range -2147483648 to 2147483647;
  res_CMP_in1 : IN integer range -2147483648 to 2147483647;
  res_CMP_execOp : IN integer range 0 to 5;
  res_CMP_out : OUT boolean
);
END res_CMP;

ARCHITECTURE rtl of res_CMP IS
BEGIN
  res_CMP_out <= res_CMP_in0 <  res_CMP_in1   when (res_CMP_execOp = 0)
       else res_CMP_in0 >  res_CMP_in1        when (res_CMP_execOp = 1)
       else res_CMP_in0 <=  res_CMP_in1        when (res_CMP_execOp = 2)
       else res_CMP_in0 >=  res_CMP_in1        when (res_CMP_execOp = 3)
       else res_CMP_in0 =  res_CMP_in1        when (res_CMP_execOp = 4)
       else res_CMP_in0 /=  res_CMP_in1;
END rtl;  -- architecture of res_CMP

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

ENTITY res_SHFT IS
port(
  res_SHFT_in0 : IN integer range -2147483648 to 2147483647;
  res_SHFT_in1 : IN integer range -2147483648 to 2147483647;
  res_SHFT_execOp : IN integer range 0 to 1;
  res_SHFT_out : OUT integer range -2147483648 to 2147483647
);
END res_SHFT;

ARCHITECTURE rtl of res_SHFT IS
BEGIN
  res_SHFT_out <= conv_integer(
            shl(conv_std_logic_vector(res_SHFT_in0, 32),
                conv_std_logic_vector(res_SHFT_in1, 32) ))
               when (res_SHFT_execOp = 0)
       else conv_integer(
                 shr(conv_std_logic_vector(res_SHFT_in0, 32),
                     conv_std_logic_vector(res_SHFT_in1, 32) ))
                 ;
END rtl;  -- architecture of res_SHFT

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

ENTITY res_ARR IS
port(
  res_ARR_in0 : IN integer range -2147483648 to 2147483647;
  res_ARR_out : OUT integer range -2147483648 to 2147483647
);
END res_ARR;

ARCHITECTURE rtl of res_ARR IS
BEGIN
  res_ARR_out <= res_ARR_in0;
END rtl;  -- architecture of res_ARR

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

ENTITY res_LOGIC IS
port(
  res_LOGIC_in0 : IN boolean;
  res_LOGIC_in1 : IN boolean;
  res_LOGIC_execOp : IN integer range 0 to 1;
  res_LOGIC_out : OUT boolean
);
END res_LOGIC;

ARCHITECTURE rtl of res_LOGIC IS
BEGIN
  res_LOGIC_out <= res_LOGIC_in0 and  res_LOGIC_in1   when (res_LOGIC_execOp = 0)
       else res_LOGIC_in0 or  res_LOGIC_in1;
END rtl;  -- architecture of res_LOGIC

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

ENTITY res_GATE IS
port(
  res_GATE_in0 : IN integer range -2147483648 to 2147483647;
  res_GATE_in1 : IN integer range -2147483648 to 2147483647;
  res_GATE_execOp : IN integer range 0 to 1;
  res_GATE_out : OUT integer range -2147483648 to 2147483647
);
END res_GATE;

ARCHITECTURE rtl of res_GATE IS
BEGIN
  res_GATE_out <= conv_integer(
            conv_std_logic_vector(res_GATE_in0, 32) and 
            conv_std_logic_vector(res_GATE_in1, 32) )
               when (res_GATE_execOp = 0)
       else conv_integer(
                 conv_std_logic_vector(res_GATE_in0, 32) or 
                 conv_std_logic_vector(res_GATE_in1, 32) )
                 ;
END rtl;  -- architecture of res_GATE

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_arith.all;
use IEEE.std_logic_signed.all;

library work;
use work.spark_pkg.all;


ENTITY main IS 
port(
  returnVar_main :  OUT wiredOrInt range -2147483648 to 2147483647 ;
  CLOCK : IN std_logic ;
  RESET : IN std_logic ;
  done : OUT std_logic );
END main;

ARCHITECTURE rtl OF main IS

  COMPONENT res_CMP
  port(
    res_CMP_in0 : IN integer range -2147483648 to 2147483647;
    res_CMP_in1 : IN integer range -2147483648 to 2147483647;
    res_CMP_execOp : IN integer range 0 to 5;
    res_CMP_out : OUT boolean
  );
  END COMPONENT;  -- end of component res_CMP

  signal sT0_13 : wiredOrBoolean  ;
  signal sT1_16 : wiredOrBoolean  ;
  signal sT2_19 : wiredOrBoolean  ;
  signal sT3_22 : wiredOrBoolean  ;
  signal sT4_25 : wiredOrBoolean  ;
  signal sT5_28 : wiredOrBoolean  ;
  signal sT6_31 : wiredOrBoolean  ;

  signal res_CMP_3_in0 : integer range -2147483648 to 2147483647 := 0;
  signal res_CMP_3_in1 : integer range -2147483648 to 2147483647 := 0;
  signal res_CMP_3_execOp : integer range 0 to 5 := 0;
  signal res_CMP_3_out : boolean;
  signal res_CMP_4_in0 : integer range -2147483648 to 2147483647 := 0;
  signal res_CMP_4_in1 : integer range -2147483648 to 2147483647 := 0;
  signal res_CMP_4_execOp : integer range 0 to 5 := 0;
  signal res_CMP_4_out : boolean;
  signal res_CMP_5_in0 : integer range -2147483648 to 2147483647 := 0;
  signal res_CMP_5_in1 : integer range -2147483648 to 2147483647 := 0;
  signal res_CMP_5_execOp : integer range 0 to 5 := 0;
  signal res_CMP_5_out : boolean;
  signal res_CMP_6_in0 : integer range -2147483648 to 2147483647 := 0;
  signal res_CMP_6_in1 : integer range -2147483648 to 2147483647 := 0;
  signal res_CMP_6_execOp : integer range 0 to 5 := 0;
  signal res_CMP_6_out : boolean;
  -- Statistics collected about this Schedule
  -- Scheduled with the following resources 
  -- 2 ALU, 1 MUL, 4 CMP, 2 SHFT, 2 ARR, 2 LOGIC, 2 GATE, 2 ALLCALLS, 
  -- Declarations of the 8 states in routine main
  subtype StateType is std_logic_vector(7 downto 0);
  CONSTANT S_0 : std_logic_vector(7 downto 0) := "00000001";
  CONSTANT S_1 : std_logic_vector(7 downto 0) := "00000010";
  CONSTANT S_2 : std_logic_vector(7 downto 0) := "00000100";
  CONSTANT S_3 : std_logic_vector(7 downto 0) := "00001000";
  CONSTANT S_4 : std_logic_vector(7 downto 0) := "00010000";
  CONSTANT S_5 : std_logic_vector(7 downto 0) := "00100000";
  CONSTANT S_6 : std_logic_vector(7 downto 0) := "01000000";
  CONSTANT S_7 : std_logic_vector(7 downto 0) := "10000000";
  signal CURRENT_STATE : StateType;
  signal NEXT_STATE : StateType;
  -- Declarations of the 5 registers in main
  signal regNum0 : integer range -2147483648 to 2147483647 := 0;
  signal regNum1 : integer range -2147483648 to 2147483647 := 0;
  signal regNum2 : integer range -2147483648 to 2147483647 := 0;
  signal regNum3 : integer range -2147483648 to 2147483647 := 0;
  signal regNum4 : integer range -2147483648 to 2147483647 := 0;
  BEGIN
    res_CMP_instance_3 : res_CMP
    port map (
      res_CMP_in0 => res_CMP_3_in0,
      res_CMP_in1 => res_CMP_3_in1,
      res_CMP_execOp => res_CMP_3_execOp,
      res_CMP_out => res_CMP_3_out
    );
    -- end of port map of component res_CMP_instance_3

    res_CMP_instance_4 : res_CMP
    port map (
      res_CMP_in0 => res_CMP_4_in0,
      res_CMP_in1 => res_CMP_4_in1,
      res_CMP_execOp => res_CMP_4_execOp,
      res_CMP_out => res_CMP_4_out
    );
    -- end of port map of component res_CMP_instance_4

    res_CMP_instance_5 : res_CMP
    port map (
      res_CMP_in0 => res_CMP_5_in0,
      res_CMP_in1 => res_CMP_5_in1,
      res_CMP_execOp => res_CMP_5_execOp,
      res_CMP_out => res_CMP_5_out
    );
    -- end of port map of component res_CMP_instance_5

    res_CMP_instance_6 : res_CMP
    port map (
      res_CMP_in0 => res_CMP_6_in0,
      res_CMP_in1 => res_CMP_6_in1,
      res_CMP_execOp => res_CMP_6_execOp,
      res_CMP_out => res_CMP_6_out
    );
    -- end of port map of component res_CMP_instance_6

    SYNC: PROCESS
    BEGIN
      wait until CLOCK'event and CLOCK = '1';
      if reset = '1' then
        CURRENT_STATE <= S_0;
        done <= '0';
      else
        CURRENT_STATE <= NEXT_STATE;
        if CURRENT_STATE /= S_0 and NEXT_STATE = S_0 then
          done <= '1';
        end if;
      end if;   -- if reset check
    END PROCESS;   -- SYNC Process

    FSM: PROCESS(CURRENT_STATE, sT6_31, sT5_28, sT4_25, sT3_22, sT2_19, sT1_16, sT0_13)
    BEGIN
      NEXT_STATE <= CURRENT_STATE;
      if CURRENT_STATE(0) = '1' then
        NEXT_STATE <= S_1;
      elsif CURRENT_STATE(1) = '1' then
        if sT0_13 then
          NEXT_STATE <= S_2;
        else  -- sT0_13        
          NEXT_STATE <= S_2;
        end if; -- conditions
      elsif CURRENT_STATE(2) = '1' then
        if sT1_16 then
          NEXT_STATE <= S_3;
        else  -- sT1_16        
          NEXT_STATE <= S_3;
        end if; -- conditions
      elsif CURRENT_STATE(3) = '1' then
        if sT2_19 then
          NEXT_STATE <= S_4;
        else  -- sT2_19        
          NEXT_STATE <= S_4;
        end if; -- conditions
      elsif CURRENT_STATE(4) = '1' then
        if sT3_22 then
          NEXT_STATE <= S_5;
        else  -- sT3_22        
          NEXT_STATE <= S_5;
        end if; -- conditions
      elsif CURRENT_STATE(5) = '1' then
        if sT4_25 then
          NEXT_STATE <= S_6;
        else  -- sT4_25        
          NEXT_STATE <= S_6;
        end if; -- conditions
      elsif CURRENT_STATE(6) = '1' then
        if sT5_28 then
          NEXT_STATE <= S_7;
        else  -- sT5_28        
          NEXT_STATE <= S_7;
        end if; -- conditions
      elsif CURRENT_STATE(7) = '1' then
        if sT6_31 then
          NEXT_STATE <= S_0;
        else  -- sT6_31        
          NEXT_STATE <= S_0;
        end if; -- conditions
      END if;  -- if (CURRENT_STATE)
    END PROCESS;   -- FSM Process

    DP: PROCESS

    BEGIN
      wait until CLOCK'event and CLOCK = '1';
      if reset = '1' then
        sT0_13 <= FALSE;
        sT1_16 <= FALSE;
        sT2_19 <= FALSE;
        sT3_22 <= FALSE;
        sT4_25 <= FALSE;
        sT5_28 <= FALSE;
        sT6_31 <= FALSE;
      else   -- else of   if reset
        if CURRENT_STATE(0) = '1' then
          sT0_13 <= res_CMP_3_out;
          sT1_16 <= res_CMP_4_out;
          sT2_19 <= res_CMP_5_out;
          sT3_22 <= res_CMP_3_out;
          returnVar_main <= 0;
        elsif CURRENT_STATE(1) = '1' then
          if sT0_13 then
            regNum0 <= a1;
          else  -- sT0_13          
            regNum0 <= a2;
          end if; -- conditions
        elsif CURRENT_STATE(2) = '1' then
          if sT1_16 then
            regNum1 <= a3;
            sT4_25 <= res_CMP_3_out;
          else  -- sT1_16          
            sT4_25 <= res_CMP_3_out;
            regNum1 <= a4;
          end if; -- conditions
        elsif CURRENT_STATE(3) = '1' then
          if sT2_19 then
            regNum2 <= a5;
          else  -- sT2_19          
            regNum2 <= a6;
          end if; -- conditions
        elsif CURRENT_STATE(4) = '1' then
          if sT3_22 then
            regNum3 <= a7;
            sT5_28 <= res_CMP_3_out;
          else  -- sT3_22          
            sT5_28 <= res_CMP_3_out;
            regNum3 <= a8;
          end if; -- conditions
        elsif CURRENT_STATE(5) = '1' then
          if sT4_25 then
            regNum0 <= regNum0;
          else  -- sT4_25          
            regNum0 <= regNum1;
          end if; -- conditions
        elsif CURRENT_STATE(6) = '1' then
          if sT5_28 then
            regNum4 <= regNum2;
            sT6_31 <= res_CMP_3_out;
          else  -- sT5_28          
            sT6_31 <= res_CMP_3_out;
            regNum4 <= regNum3;
          end if; -- conditions
        elsif CURRENT_STATE(7) = '1' then
          if sT6_31 then
            regNum0 <= regNum0;
          else  -- sT6_31          
            regNum0 <= regNum4;
          end if; -- conditions
        END if;  -- if (CURRENT_STATE)
      end if;   -- end of   if reset
    END PROCESS;   -- DP Process

    res_CMP_3_in0_MUXES: PROCESS(CURRENT_STATE
        , a1, a7, sT1_16, regNum0, sT1_16, regNum0, sT3_22, regNum2, sT3_22
        , regNum2, sT5_28, regNum0, sT5_28, regNum0)
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000001";
      end if;
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000010";
      end if;
      if (CURRENT_STATE(2) = '1' and sT1_16) then
        mux_select := "0000000100";
      end if;
      if (CURRENT_STATE(2) = '1' and NOT(sT1_16)) then
        mux_select := "0000001000";
      end if;
      if (CURRENT_STATE(4) = '1' and sT3_22) then
        mux_select := "0000010000";
      end if;
      if (CURRENT_STATE(4) = '1' and NOT(sT3_22)) then
        mux_select := "0000100000";
      end if;
      if (CURRENT_STATE(6) = '1' and sT5_28) then
        mux_select := "0001000000";
      end if;
      if (CURRENT_STATE(6) = '1' and NOT(sT5_28)) then
        mux_select := "0010000000";
      end if;
      case mux_select is
        when "0000000001" => 
          res_CMP_3_in0 <= a1;
        when "0000000010" => 
          res_CMP_3_in0 <= a7;
        when "0000000100" => 
          res_CMP_3_in0 <= regNum0;
        when "0000001000" => 
          res_CMP_3_in0 <= regNum0;
        when "0000010000" => 
          res_CMP_3_in0 <= regNum2;
        when "0000100000" => 
          res_CMP_3_in0 <= regNum2;
        when "0001000000" => 
          res_CMP_3_in0 <= regNum0;
        when "0010000000" => 
          res_CMP_3_in0 <= regNum0;
        when others => 
          res_CMP_3_in0 <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_3_in0_MUXES END PROCESS;

    res_CMP_3_in1_MUXES: PROCESS(CURRENT_STATE
        , a2, a8, sT1_16, a3, sT1_16, a4, sT3_22, a7, sT3_22
        , a8, sT5_28, regNum2, sT5_28, regNum3)
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000001";
      end if;
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000010";
      end if;
      if (CURRENT_STATE(2) = '1' and sT1_16) then
        mux_select := "0000000100";
      end if;
      if (CURRENT_STATE(2) = '1' and NOT(sT1_16)) then
        mux_select := "0000001000";
      end if;
      if (CURRENT_STATE(4) = '1' and sT3_22) then
        mux_select := "0000010000";
      end if;
      if (CURRENT_STATE(4) = '1' and NOT(sT3_22)) then
        mux_select := "0000100000";
      end if;
      if (CURRENT_STATE(6) = '1' and sT5_28) then
        mux_select := "0001000000";
      end if;
      if (CURRENT_STATE(6) = '1' and NOT(sT5_28)) then
        mux_select := "0010000000";
      end if;
      case mux_select is
        when "0000000001" => 
          res_CMP_3_in1 <= a2;
        when "0000000010" => 
          res_CMP_3_in1 <= a8;
        when "0000000100" => 
          res_CMP_3_in1 <= a3;
        when "0000001000" => 
          res_CMP_3_in1 <= a4;
        when "0000010000" => 
          res_CMP_3_in1 <= a7;
        when "0000100000" => 
          res_CMP_3_in1 <= a8;
        when "0001000000" => 
          res_CMP_3_in1 <= regNum2;
        when "0010000000" => 
          res_CMP_3_in1 <= regNum3;
        when others => 
          res_CMP_3_in1 <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_3_in1_MUXES END PROCESS;

    res_CMP_3_execOpMUXES: PROCESS(CURRENT_STATE 
        , sT1_16, sT1_16, sT3_22, sT3_22
        , sT5_28, sT5_28)
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000001";
      end if;
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000010";
      end if;
      if (CURRENT_STATE(2) = '1' and sT1_16) then
        mux_select := "0000000100";
      end if;
      if (CURRENT_STATE(2) = '1' and NOT(sT1_16)) then
        mux_select := "0000001000";
      end if;
      if (CURRENT_STATE(4) = '1' and sT3_22) then
        mux_select := "0000010000";
      end if;
      if (CURRENT_STATE(4) = '1' and NOT(sT3_22)) then
        mux_select := "0000100000";
      end if;
      if (CURRENT_STATE(6) = '1' and sT5_28) then
        mux_select := "0001000000";
      end if;
      if (CURRENT_STATE(6) = '1' and NOT(sT5_28)) then
        mux_select := "0010000000";
      end if;
      case mux_select is
        when "0000000001" => 
          res_CMP_3_execOp <= 0 ;
        when "0000000010" => 
          res_CMP_3_execOp <= 0 ;
        when "0000000100" => 
          res_CMP_3_execOp <= 0 ;
        when "0000001000" => 
          res_CMP_3_execOp <= 0 ;
        when "0000010000" => 
          res_CMP_3_execOp <= 0 ;
        when "0000100000" => 
          res_CMP_3_execOp <= 0 ;
        when "0001000000" => 
          res_CMP_3_execOp <= 0 ;
        when "0010000000" => 
          res_CMP_3_execOp <= 0 ;
        when others => 
          res_CMP_3_execOp <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_3_execOp_MUXES END PROCESS;

    res_CMP_4_in0_MUXES: PROCESS(CURRENT_STATE
        , a3)
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000001";
      end if;
      case mux_select is
        when "0000000001" => 
          res_CMP_4_in0 <= a3;
        when others => 
          res_CMP_4_in0 <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_4_in0_MUXES END PROCESS;

    res_CMP_4_in1_MUXES: PROCESS(CURRENT_STATE
        , a4)
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000001";
      end if;
      case mux_select is
        when "0000000001" => 
          res_CMP_4_in1 <= a4;
        when others => 
          res_CMP_4_in1 <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_4_in1_MUXES END PROCESS;

    res_CMP_4_execOpMUXES: PROCESS(CURRENT_STATE 
        )
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000001";
      end if;
      case mux_select is
        when "0000000001" => 
          res_CMP_4_execOp <= 0 ;
        when others => 
          res_CMP_4_execOp <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_4_execOp_MUXES END PROCESS;

    res_CMP_5_in0_MUXES: PROCESS(CURRENT_STATE
        , a5)
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000001";
      end if;
      case mux_select is
        when "0000000001" => 
          res_CMP_5_in0 <= a5;
        when others => 
          res_CMP_5_in0 <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_5_in0_MUXES END PROCESS;

    res_CMP_5_in1_MUXES: PROCESS(CURRENT_STATE
        , a6)
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000001";
      end if;
      case mux_select is
        when "0000000001" => 
          res_CMP_5_in1 <= a6;
        when others => 
          res_CMP_5_in1 <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_5_in1_MUXES END PROCESS;

    res_CMP_5_execOpMUXES: PROCESS(CURRENT_STATE 
        )
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
      if (CURRENT_STATE(0) = '1') then
        mux_select := "0000000001";
      end if;
      case mux_select is
        when "0000000001" => 
          res_CMP_5_execOp <= 0 ;
        when others => 
          res_CMP_5_execOp <= 0;
      END CASE;
    END PROCESS;	 -- res_CMP_5_execOp_MUXES END PROCESS;

    res_CMP_6_in0_MUXES: PROCESS(CURRENT_STATE)
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
    END PROCESS;	 -- res_CMP_6_in0_MUXES END PROCESS;

    res_CMP_6_in1_MUXES: PROCESS(CURRENT_STATE)
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
    END PROCESS;	 -- res_CMP_6_in1_MUXES END PROCESS;

    res_CMP_6_execOpMUXES: PROCESS(CURRENT_STATE )
      variable mux_select : std_logic_vector(9 downto 0);
    BEGIN
      mux_select := "0000000000";
    END PROCESS;	 -- res_CMP_6_execOp_MUXES END PROCESS;

END rtl;
